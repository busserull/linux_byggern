\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{tikz}
\usepackage{graphicx}

\usepackage{todonotes}

\newcommand{\warning}[1]{
\noindent
\fbox{
\begin{minipage}{0.1\linewidth}
\raisebox{-6em}{
\scalebox{3}{%
\makebox[2.1em][c]{%
\makebox[0pt][c]{\raisebox{0.3em}{\large!}}%
\makebox[0pt][c]{\color{red}\Huge$\bigtriangleup$}}}
}
\end{minipage}
\begin{minipage}{0.1\linewidth}
\hfill
\end{minipage}
\begin{minipage}{0.7\linewidth}
\vspace{1em}
#1
\vspace{1em}
\end{minipage}
\begin{minipage}{0.05\linewidth}
\hfill
\end{minipage}
}
}

\title{Introducing Bluetooth Low Energy}
\author{Kolbj√∏rn Austreng}
\date{}

\begin{document}
\maketitle

\renewcommand{\thesection}{\roman{section}}
\renewcommand{\thesubsection}{\roman{section}.\alph{subsection}}

\section{Introduction}
Wired protocols are all well and nice - and although CAN is a relatively old protocol now partly superseded by CAN-FD (ISO 11898); it is still widely used today. Nevertheless, wireless protocols are becoming increasingly popular wherever they can be used, due to their low cost, and ease of use.\\
\\
One such protocol - Bluetooth Low Energy, or Bluetooth 4.2 (BLE for short) - is almost certainly supported by your smart phone; as well as a plethora of different devices, prevalent in our daily life. This makes it an ideal candidate for introducing wireless connectivity to your project - provided you can live with the interference present in the ISM band.\\
\\
Many of the students taking this course will previously have had the course "Embedded Systems" (TTK4235), in which the "BBC micro:bit" development board was used during the labs. This is an excellent platform for introducing the Bluetooth Low Energy stack, and we will be using the micro:bit platform in this course as well. TTK4235 is no prerequisite, and it should be straight forward to follow this lab assignment without having gone through that course.\\
\\
If no one on your group has a micro:bit, you may talk to one of the student assistants. It is also possible to use other hardware, such as an nRF52 development kit if you happen to have one, but bear in mind that other hardware platforms support different Application Programming Interfaces (APIs) for the Bluetooth stack.

\newpage
\noindent
\section{Initial Setup of Hardward and Toolchain}
The following hardware configuration is only necessary for those of you who have not already done so through TTK4235. However, it might still be necessary to set up the toolchain, as nothing is certain when it comes to the computers at the real time lab.

\subsection{Hardware Configuration}
By default, the micro:bit comes preloaded with a custom Device Abstraction Layer (DAL) that allows programming the device through Scratch, Micropython, or JavaScript. This is well for simple demonstrations, but yields no control of the low level hardware. To get around this limitation, we will upgrade the flasher circuit to use the BBC micro:bit J-Link OB Firmware.

\begin{enumerate}
\item Download the \href{https://www.segger.com/downloads/jlink#BBC\_microbit}{J-Link OB Firmware from Segger.com}\footnote{https://www.segger.com/downloads/jlink\#BBC\_microbit}.
\item Start with the micro:bit unplugged. While holding down the Reset button (next to the USB connector), connect it to the computer.
\item The micro:bit should now have mounted itself as "MAINTENANCE" on the file system. You can now let go of the Reset button.
\item Move the .hex-file that you downloaded into "MAINTENANCE".
\item The micro:bit should now automatically remount after a few seconds; this time as "MICROBIT".
\end{enumerate}

\subsection{Toolchain Configuration}
\label{sec::toolchain_config}
To compile and flash code for the micro:bit, we need to install a toolchain. For compilation, GCC is a natural choice. Since the heart of the micro:bit is an nRF51822, we will be using J-Link and nrfjprog to flash the board.

\begin{enumerate}
\item Call \mintinline{text}{nrfjprog --version} to see if the toolchain is already set up on the computer. If it is, you may skip the remaining steps.
\item Call \mintinline{text}{sudo apt install gcc-arm-none-eabi} to install the GCC ARM compiler.
\item Go to \href{https://www.nordicsemi.com/eng/nordic/Products/nRF51822/nRF5x-Command-Line-Tools-Linux64/51386}{nordicsemi.com}\footnote{https://www.nordicsemi.com/eng/nordic/Products/nRF51822/nRF5x-Command-Line-Tools-Linux64/51386} and download the newest version of the nRF command line tools.
\item The download contains the programs \mintinline{text}{nrfjprog} and \mintinline{text}{mergehex}, both must be available in the Linux \mintinline{text}{PATH} variable. This can be done in many ways, here is one:
\begin{enumerate}
\item Extract the \mintinline{text}{nrfjprog}- and \mintinline{text}{mergehex} folders to the home folder.
\item Add the following string at the bottom of the \mintinline{text}{~/.bashrc} file: \mintinline{bash}{"export PATH=$HOME/nrfjprog:$HOME/mergehex:$PATH"} (do not include the quotation marks)%$
\item Finally, since \mintinline{text}{~/.bashrc} is read once when a terminal opens, you need to close and reopen all terminal windows that you might have active.
\end{enumerate}
\item Go to \href{https://www.segger.com/downloads/jlink/\#J-LinkSoftwareAndDocumentationPack}{segger.com}\footnote{https://www.segger.com/downloads/jlink/\#J-LinkSoftwareAndDocumentationPack} and download the J-Link Software and Documentation pack. You should choose the Linux 64 bit version, DEB installer.
\item Once you have downloaded the DEB package, navigate to the download location with a terminal, and call the following command to install the package: \mintinline{text}{sudo dpkg -i JLink_Linux[...]x86_64.deb}
\end{enumerate}

\subsection{Hardware and Toolchain Verification}
First off, you should call \mintinline{text}{nrfjprog --version} to see if the toolchain is set up. If this command complains, you will need to repeat section \ref{sec::toolchain_config}.\\
\\
On Blackboard, you can find an example .hex-file, aptly named "example.hex". To flash this file to the micro:bit, navigate to the directory where you have the hex, and call:
\begin{minted}{bash}
nrfjprog -f nrf51 --chiperase --program example.hex --reset
\end{minted}
The micro:bit should now start broadcasting the name "u:bit" over Bluetooth. To verify this, you may use your phone, as described in section \ref{sec::phone_verify}.

\section{Use your phone for testing}
\label{sec::phone_verify}
You are free to use whatever to check your Bluetooth connection, but an easy choice is to download the "nRF Connect" app for your smart phone. This lab assignment will use that app.\\
\\
When you open nRF Connect, your phone will start scanning for advertising packets, as seen in figure \ref{fig::example_scanning}. You can adjust the RSSI filter (signal strength) to only show devices that are close to you. In the image, this filter is set to $-80$ dBm, but setting it to around $-60$ dBm is probably better if there are a lot of Bluetooth devices nearby.\\
\\
When you connect to the micro:bit, you will see something similar to figure \ref{fig::example_services}. The names "LED Matrix" and "Buttons" will not show up by default, but may be assigned by you, by long-pressing on the \textit{characteristic} and editing the name. Either way, the name of the characteristic is merely cosmetic.\\
\\
By uploading a byte different than 0x00 to the "LED Matrix" characteristic, the LED matrix should turn on; and it should turn off when you upload 0x00.\\
\\
The "Buttons" characteristic contains the state of the two micro:bit tactile buttons. You may read their state \textit{once} by pressing the download icon - or you may \textit{subscribe} to state updates by pressing the "notify" icon (The solid line with three arrows pointing down). With subscriptions turned on, you should see the state of the buttons update on the screen as you press- and release the buttons.

\begin{figure}[ht]
\centering
\begin{minipage}{0.5\linewidth}
\centering
\includegraphics[width=0.9\linewidth]{example_connect_scan.png}
\caption{nRF Connect scanning.}
\label{fig::example_scanning}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\centering
\includegraphics[width=0.9\linewidth]{example_connect_gatt.png}
\caption{Example services.}
\label{fig::example_services}
\end{minipage}
\end{figure}

\newpage
\noindent
\setcounter{section}{0}
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}

\section{Heads up}
Bluetooth Low Energy (BLE) is a messy beast to tackle, so it might be smart to skim appendix \ref{app::intro_ble} as you go through this lab assignment. Don't fret if you do not get all the details however - some things are better understood when coded, rather than when read.\\
\\
Finally, an honest word from the author of this assignment: Sometimes, the Nordic Semi documentation can be a little "Meh". Feeling like there should be a more elegant way to do Bluetooth Low Energy is completely normal - and you are advised to simply bite the pillow when the going gets rough.\\
\\
Do enjoy :)

\section{First steps - GAP}
The gatekeeper of Bluetooth is the \textit{Generic Access Profile}. This is the part of Bluetooth that handles broadcasting, discovery, the setting up- and managing connections, as well as negotiating security levels.\\
\\
Although GAP is used to establish connections, GAP itself is connectionless, and pretty simple. The bottom line is this: When advertising, a Bluetooth device sends out an \textit{Advertising Packet} of 31 bytes every advertising interval - which can be anything between $20$ milliseconds and $10.24$ seconds.\\
\\
In addition to this, anyone observing the advertiser can send a \textit{scan request} to the device. Upon receiving such a scan request, the device \textit{may} respond with a \textit{Scan Response Packet}, which is also 31 bytes and can contain different information than the Advertising Packet. Note that the device is not required to respond to scan requests, however.\\
\\
GAP happens entirely on the Bluetooth channels 37, 38, and 39, which are reserved for advertising - as illustrated in figure \ref{fig::bluetooth_spectrum} in appendix \ref{app::intro_ble}. The reason that exactly these channels were chosen for advertising is to avoid most of the interference from WiFi, which is most noticeable on the channels 0-9, 11-20, and 23-32.\\
\\
To make matters a little more interesting, the Bluetooth 4.2 specification specifies 4 different ways a device can advertise. The nuances of this is not terribly important for this course, but they are listed here for the interested:
\begin{itemize}
\item \mintinline{text}{ADV_IND}: "Connectable undirected advertising". This is the regular way to advertise. Any other device can request a scan response or a connection.
\item \mintinline{text}{ADV_DIRECT_IND}: "Connectable directed advertising". This is used to ask a specific central for a connection. The packet is a broadcast packet, but scanners will ignore it if the peer address does not match them. In addition, the advertiser itself will ignore all scan requests.
\item \mintinline{text}{ADV_SCAN_IND}: "Scannable undirected advertising". In this mode, the advertiser will ignore all connection requests, but may respond to scan requests.
\item \mintinline{text}{ADV_NONCONN_IND}: "Non-connectable undirected advertising". This is essentially just an information beacon; the advertiser will ignore all scan- and connection requests, and will simply spew out its own Advertising Packets until the end of time.
\end{itemize}

\subsection{Advertising Packet Format}
Even though the Advertising Packet (and Scan Response Packet) consists of 31 bytes, not all are usable by the application programmer. This is because the packet is subdivided into a number of \textit{AD Structs} - or "Advertising Data Structures". Actually, truth be told, each Advertising Packet may \textit{really} send out 47 bytes over the air each advertising interval, but a lot of this is overhead, as illustrated in figure \ref{fig::pdu_breakdown}. The squares with just numbers in them denote fields that are necessary, but not of direct interest to us.\\
\begin{figure}[ht]
\centering
\input{ad_struct_pdu_breakdown.pgf}
\caption{Breakdown of each GAP advertising transmission unit.}
\label{fig::pdu_breakdown}
\end{figure}\\
Despite the fact that we do not really get to use all the 31 bytes in the advertising data, we must still hand craft the entire field to comply with with the Bluetooth 4.2 spec in our code. In fact, you can see the advertising data used in the example program in listing \ref{code::example_advertise_data}.\\
\begin{listing}[hb]
\begin{minted}{c}
uint8_t adv_data[] = {
	6, BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME,
	'u', ':', 'b', 'i', 't',
	3, BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
	0x0D, 0xF0
};
uint8_t adv_data_length = 11;
\end{minted}
\caption{The advertising data field from the example hex.}
\label{code::example_advertise_data}
\end{listing}\\
Note that the advertising data does not have to use all the 31 bytes available. This allows us to reduce power consumption a little if we have a really resource constrained application.
\\
\\
\warning{Hey there!}


\newpage
\noindent
\appendix
\section{Introduction to BLE}
\label{app::intro_ble}
\begin{figure}
\centering
\resizebox{\linewidth}{!}{
\input{channel_spectrum.pgf}
}
\caption{The Bluetooth channel spectrum.}
\label{fig::bluetooth_spectrum}
\end{figure}
Blah blah


\end{document}
